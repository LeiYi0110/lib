/*
 * äº?          å“?:  DEPä¸šåŠ¡åŸºç¡€å¹³å°
 * æ–?   ä»?  å?:  PasswordEncoder.java
 * ç‰?          æ?:  æ·±åœ³å¸‚è¿ªåšä¼ä¸šç®¡ç†æŠ€æœ¯æœ‰é™å…¬å? Copyright 2011-2020,  All rights reserved
 * æ?          è¿?:  DEPä¸šåŠ¡åŸºç¡€å¹³å°æ˜¯æ·±åœ³è¿ªåšä¼ä¸šé£é™©ç®¡ç†æŠ€æœ¯æœ‰é™å…¬å¸è‡ªä¸»ç ”å‘çš„ä¸šåŠ¡åŸºç¡€å¹³å°ã€‚æ˜¯é¢å‘
 *            ä¸šåŠ¡åº”ç”¨çš„ç®¡ç†è½¯ä»¶å¼€å‘å¹³å°ã?‚å¸®åŠ©è½¯ä»¶å¼€å‘äººå‘˜çªç ´æŠ€æœ¯ç“¶é¢ˆï¼Œå®ç°å°‘å†™æºä»£ç æˆ–
 *            ä¸å†™æºä»£ç ã?å¿«é€Ÿåœ°å¼?å‘åº”ç”¨è½¯ä»¶çš„ç›®çš„ã€?
 * åˆ?   å»?  äº?:  wenbing.zhang
 * åˆ›å»ºæ—¶é—´:  2012-5-23
 */
package com.bjxc.utils.encide;



/**
 * <p>
 * Interface for performing authentication operations on a password.
 * </p>
 *
 * @author colin sampaleanu
 * @version $Id: PasswordEncoder.java 2217 2007-10-27 00:45:30Z luke_t $
 */
public interface PasswordEncoder {
    //~ Methods ========================================================================================================

    /**
     * <p>Encodes the specified raw password with an implementation specific algorithm.</p>
     *  <P>This will generally be a one-way message digest such as MD5 or SHA, but may also be a plaintext
     * variant which does no encoding at all, but rather returns the same password it was fed. The latter is useful to
     * plug in when the original password must be stored as-is.</p>
     *  <p>The specified salt will potentially be used by the implementation to "salt" the initial value before
     * encoding. A salt is usually a user-specific value which is added to the password before the digest is computed.
     * This means that computation of digests for common dictionary words will be different than those in the backend
     * store, because the dictionary word digests will not reflect the addition of the salt. If a per-user salt is
     * used (rather than a system-wide salt), it also means users with the same password will have different digest
     * encoded passwords in the backend store.</p>
     *  <P>If a salt value is provided, the same salt value must be use when calling the  {@link
     * #isPasswordValid(String, String, Object)} method. Note that a specific implementation may choose to ignore the
     * salt value (via <code>null</code>), or provide its own.</p>
     *
     * @param rawPass the password to encode
     * @param salt optionally used by the implementation to "salt" the raw password before encoding. A
     *        <code>null</code> value is legal.
     *
     * @return encoded password
     *
     * @throws DataAccessException DOCUMENT ME!
     */
    String encodePassword(String rawPass, Object salt);

    /**
     * <p>Validates a specified "raw" password against an encoded password.</p>
     *  <P>The encoded password should have previously been generated by {@link #encodePassword(String,
     * Object)}. This method will encode the <code>rawPass</code> (using the optional <code>salt</code>),  and then
     * compared it with the presented <code>encPass</code>.</p>
     *  <p>For a discussion of salts, please refer to {@link #encodePassword(String, Object)}.</p>
     *
     * @param encPass a pre-encoded password
     * @param rawPass a raw password to encode and compare against the pre-encoded password
     * @param salt optionally used by the implementation to "salt" the raw password before encoding. A
     *        <code>null</code> value is legal.
     *
     * @return true if the password is valid , false otherwise
     *
     * @throws DataAccessException DOCUMENT ME!
     */
    boolean isPasswordValid(String encPass, String rawPass, Object salt);
}
